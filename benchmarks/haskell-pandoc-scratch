module Main where
import Text.Pandoc
import Data.Text (Text)  -- Imports only the Text type from the Data.Text module.
import qualified Data.Text.IO as T 
  -- Imports the Data.Text.IO module under the alias T.
  -- Data.Text.IO provides input/output functions for Text, like readFile, putStrLn, getContents.
  -- The qualified ... as T means you have to prefix the functions with T.:

mdToRST :: Text -> IO Text
mdToRST txt = runIOorExplode $
                readMarkdown def txt
                >>= writeRST def{ writerReferenceLinks = True }

main :: IO ()
main = do
  T.getContents >>= mdToRST >>= T.putStrLn

=======================================
  
mdToRST :: Text -> IO Text
mdToRST txt =
  runIOorExplode
    (bind (readMarkdown def txt)
          (\pandoc ->
             writeRST (def { writerReferenceLinks = True }) pandoc
          )
    )

main :: IO ()
main =
  bind T.getContents
       (\input ->
          bind (mdToRST input)
               (\rst ->
                  T.putStrLn rst
               )
       )
==========================================

mdToRST :: Text -> IO Text
mdToRST txt = do
  pandoc <- readMarkdown def txt
  writeRST (def { writerReferenceLinks = True }) pandoc

main :: IO ()
main = do
  input <- T.getContents
  rst <- mdToRST input
  T.putStrLn rst
  

==========================================
-- PandocPure version

import Text.Pandoc
import Text.Pandoc.Class (PandocMonad(..))
import Data.Text (Text)

mdToRST :: Text -> PandocPure Text
mdToRST txt = do
  doc <- readMarkdown def txt
  writeRST def { writerReferenceLinks = True } doc

example :: Text -> Text
example input =
  case runPure (mdToRST input) of
    Left err -> "Error: " <> T.pack (show err)
    Right rst -> rst

example (T.pack "Hello!") -- always works


-- runIO and runPure return an Either PandocError a. All errors raised in running a PandocMonad computation will be trapped and returned as a Left value, so they can be handled by the calling program. To see the constructors for PandocError, see the documentation for Text.Pandoc.Error.


==========================================

mdToRST :: Text -> IO Text
mdToRST txt = writeRST def (readMarkdown def txt)

main :: IO ()
main = T.putStrLn (mdToRST T.getContents)

-- The above doesn't work here since the <- is monadic. We need to support lambdas and bind and monads and stuff. But that requires that we have subtyping

==========================================

-- THE TWO DEFS HERE ARE DIFFERENT - one is ReaderOptions, the other WriterOptions
-- Haskell knows from type inference which def we're referring to, but we should use different names

main = T.putStrLn (writeRST def (readMarkdown def T.getContents))

-- def (from Data.Default) denotes a default value for each kind of option. (You can also use defaultWriterOptions and defaultReaderOptions.)
-- https://pandoc.org/using-the-pandoc-api.html
main = T.putStrLn (writeRST defaultWriterOptions (readMarkdown defaultReaderOptions T.getContents))
==========================================



import Text.Pandoc.Definition
import Text.Pandoc.Generic
import Data.Char (toUpper)

modHeader :: Block -> Block
modHeader (Header n _ xs) | n >= 3 = Para $ bottomUp allCaps xs
modHeader x = x

allCaps :: Inline -> Inline
allCaps (Str xs) = Str $ map toUpper xs
allCaps x = x

changeHeaders :: Pandoc -> Pandoc
changeHeaders = bottomUp modHeader
==========================================


Here is a simple example of the use of a pandoc reader and writer to perform a conversion:

import Text.Pandoc
import qualified Data.Text as T
import qualified Data.Text.IO as TIO

main :: IO ()
main = do
  result <- runIO $ do
    doc <- readMarkdown def (T.pack "[testing](url)")
    writeRST def doc
  rst <- handleError result
  TIO.putStrLn rst

Some notes:

The first part constructs a conversion pipeline: the input string is passed to readMarkdown, and the resulting Pandoc AST (doc) is then rendered by writeRST. The conversion pipeline is “run” by runIO—more on that below.

result has the type Either PandocError Text. We could pattern-match on this manually, but it’s simpler in this context to use the handleError function from Text.Pandoc.Error. This exits with an appropriate error code and message if the value is a Left, and returns the Text if the value is a Right.


Very useful:
https://pandoc.org/using-the-pandoc-api.html#handling-errors-and-warnings
