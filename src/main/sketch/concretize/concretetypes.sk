package ct;
include "/home/vivianyyd/type-synth/src/main/sketch/util.sk";

adt Type {
    Variable { int tid; int vid; }
    Label { int l; List@list<Type> params; }
    Function { Type left; Type rite; }
}

struct Binding { int tid; int vid; Type t; }

Type applyBinding(Type t, int tid, int vid, Type sub) {
    switch (t) {
        case Label:{
            return new Label(l=t.l, params=applyBindingToAll(t.params, tid, vid, sub, 4));
        }
        case Function:{
            return new Function(left=applyBinding(t.left, tid, vid, sub), rite=applyBinding(t.rite, tid, vid, sub));
        }
        case Variable:{
            if (t.tid == tid && t.vid == vid) return sub;
            else return t;
        }
    }
}

List@list<Type> applyBindingToAll(List@list<Type> types, int tid, int vid, Type sub, int bnd) {
    assert bnd > 0;
    switch (types) {
        case Cons:{
            return add(applyBindingToAll(types.next, tid, vid, sub, bnd - 1), applyBinding(types.val, tid, vid, sub));
        }
        case Nil:{ return empty(); }
    }
}

Type applyBindings(Type t, List@list<Binding> bindings) {
    switch (bindings) {
        case Cons:{ return applyBindings(applyBinding(t, bindings.val.tid, bindings.val.vid, bindings.val.t), bindings.next); }
        case Nil:{ return t; }
    }
}

List@list<Type> applyBindingsToAll(List@list<Type> types, List@list<Binding> bindings, int bnd) {
    assert bnd > 0;
    switch (types) {
        case Cons:{ return add(applyBindingsToAll(types.next, bindings, bnd - 1), applyBindings(types.val, bindings)); }// todo since ground,label both capped at 4
        case Nil:{ return empty(); }
    }
}

List@list<Binding> unifyAll(List@list<Type> params, List@list<Type> args, boolean posFlag, int bnd) {
    assert bnd > 0;
    assert(len(params) == len(args));
    switch (params) {
        case Cons:{
            switch (args) {
                case Cons:{
                    List@list<Binding> bindings = unify(params.val, args.val, posFlag, bnd);  // TODO is it fine that these are the same, I think yes bc this fn call just redirects and stays on same level
                    if (bindings == null) return fail(posFlag);
                    List@list<Type> newParams = applyBindingsToAll(params.next, bindings, 4);  // TODO we can bound this by the max number of label parameters or even true number or min(maxnum, true num)
                    List@list<Binding> remainingBindings = unifyAll(newParams, args.next, posFlag, bnd);
                    if (remainingBindings == null) return fail(posFlag);
                    return plus(bindings, remainingBindings);
                }
                case Nil:{ assert false; }
            }
        }
        case Nil:{
            switch (args) {
                case Cons:{ assert false; }
                case Nil:{ return empty(); }
            }
        }
    }
}

generator List@list<Binding> fail(boolean posFlag) {
    if (posFlag) assert false;
    else return null;
}

/** Returns a list of bindings resulting from unifying [arg] with [param], or null if they are incompatible. */
List@list<Binding> unify(Type param, Type arg, boolean posFlag, int bnd) {
    assert bnd > 0;
    switch(param) {
        case Variable:{
            Binding b = new Binding(tid=param.tid, vid=param.vid, t=arg);
            return single(b);
        }
        case Label:{
            switch(arg) {
                case Variable:{ assert false; }  // TODO I think invariant. If we had []: L<a> this would be different
                case Label:{
                    if (param.l != arg.l || len(param.params) != len(arg.params)) return fail(posFlag);
                    return unifyAll(param.params, arg.params, posFlag, bnd - 1);
                }
                case Function:{ return fail(posFlag); }
            }
        }
        case Function:{
            switch(arg) {
                case Variable:{ assert false; }  // TODO I think invariant
                case Label:{ return fail(posFlag); }
                case Function:{
                    List@list<Binding> leftBindings = unify(param.left, arg.left, posFlag, bnd - 1);
                    if (leftBindings == null) return fail(posFlag);
                    Type newParamRight = applyBindings(param.rite, leftBindings);
                    List@list<Binding> riteBindings = unify(newParamRight, arg.rite, posFlag, bnd - 1);
                    if (riteBindings == null) return fail(posFlag);
                    return plus(leftBindings, riteBindings);
                }
            }
        }
    }
}

/**
 Returns the output type of [fn] on input [arg] with no free variables, or null if [arg] is invalid for [fn].
 */
Type apply(Function fn, Type arg, boolean posFlag) {
    List@list<Binding> b = unify(fn.left, arg, posFlag, 5);  // TODO FIXME JUST PATCHED IN
    if (b == null) {
        if (posFlag) assert false;
        else return null;
    }
    return applyBindings(fn.rite, b);
}

boolean isFunction(Type t) {
    switch(t) {
        case Variable:{ return false; }  // TODO think about this
        case Label:{ return false; }
        case Function:{ return true; }
    }
}

struct LabelKind { int l; int numParams; }

List@list<LabelKind> makeLabelKinds(ref int numLKs) {
    int nKinds = ??(3);
    minimize (nKinds);
    List@list<LabelKind> register = empty();
    for (int i = 0; i < nKinds; i++) {
        int nParams = ??(2);
        minimize (nParams);
        register = add(register, new LabelKind(l=i, numParams=nParams));
    }
    numLKs = len(register);
    return register;
}

generator int makeLabelVars() {
    int nVars = ??(2);
    minimize (nVars);
    return nVars;
}

// BOUND ON NUMBER OF LABEL KINDS: 8
// BOUND ON NUMBER OF PARAMS FOR A LABEL: 4
// BOUND ON NUMBER OF FRESH VARIABLES INSIDE ONLY LABELS FOR A GIVEN TYPE: 4

// LABEL BOUND DEPTH IS SPECIFIED BY GENERATED CODE
// TODO generated code tells us how deep the type is above any label. Then our upper bound on unify inlining is
//   max label depth + type above
//
//generator Label label(List@list<LabelKind> register, int numLKs, int tid, int groundVars, int labelVars) {
//    return label_b(register, numLKs, tid, groundVars, labelVars, 3);
//}
//generator Label clabel(List@list<LabelKind> register, int numLKs, int tid, int groundVars, int labelVars) {
//    return clabel_b(register, numLKs, tid, groundVars, labelVars, 3);
//}

generator Type type(List@list<LabelKind> register, int numLKs, int tid, int groundVars, int labelVars, Constraint c, int bnd) {
    assert bnd > 0;
    if (c != null) {
        switch(c) {
            case NoVars: {
                bit t = ??;
                if (t) {
                    return label(register, numLKs, tid, groundVars, labelVars, c, bnd - 1);
                }
                else {
                    Type a = type(register, numLKs, tid, groundVars, labelVars, c, bnd - 1);
                    Type b = type(register, numLKs, tid, groundVars, labelVars, c, bnd - 1);
                    return new Function(left=a, rite=b);
                }
                assert false;
            }
            case OnlyVariable: {
                int t = ??(2);
                if (t == 0) {
                    return new Variable(tid=c.tid, vid=c.vid);
                }
                if (t == 1) {
                    return label(register, numLKs, tid, groundVars, labelVars, c, bnd - 1);
                }
                if (t == 2) {
                    Type a = type(register, numLKs, tid, groundVars, labelVars, c, bnd - 1);
                    Type b = type(register, numLKs, tid, groundVars, labelVars, c, bnd - 1);
                    return new Function(left=a, rite=b);
                }
                assert false;
            }
        }
    }
    else {
        int t = ??(2);
        if (t == 0) {
            return variable(tid, groundVars, labelVars);
        }
        if (t == 1) {
            return label(register, numLKs, tid, groundVars, labelVars, c, bnd - 1);
        }
        if (t == 2) {
            Type a = type(register, numLKs, tid, groundVars, labelVars, c, bnd - 1);
            Type b = type(register, numLKs, tid, groundVars, labelVars, c, bnd - 1);
            return new Function(left=a, rite=b);
        }
        assert false;
    }
}

generator Label label(List@list<LabelKind> register, int numLKs, int tid, int groundVars, int labelVars, Constraint c, int bnd) {
    assert bnd > 0;
    int ind = ??(3);
    assert (ind < numLKs);
    LabelKind lk = get(register, ind);
    List@list<Type> params = empty();
    for (int i = 0; i < lk.numParams; i++) {
        params = add(params, type(register, numLKs, tid, groundVars, labelVars, c, bnd - 1));
    }
    return new Label(l=lk.l, params=params);
}

generator Variable variable(int tid, int groundVars, int labelVars) {  // TODO if no groundvars, v can be bound at 2, so should actually pass its bit bound in here
    int v = ??(3); // labelVars bounded at 4; we assumed groundVars < 4  // TODO don't hardcode me
    assert (v < groundVars + labelVars);
    return new Variable(tid=tid, vid=v);
    // TODO we can add preference to variables bound outside of labels but that would be oddly asymmetric
}

generator Variable variableInLabel(int tid, int groundVars, int labelVars) {
    int v = ??(2);
    assert (v < labelVars);
    return new Variable(tid=tid, vid=groundVars + v);
}

generator Label clabel(List@list<LabelKind> register, int numLKs, int tid, int groundVars, Constraint c, int bnd) {
    assert bnd > 0;
    int ind = ??(3);
    assert (ind < numLKs);
    LabelKind lk = get(register, ind);
    List@list<Type> params = empty();
    for (int i = 0; i < lk.numParams; i++) {
        params = add(params, ctype(register, numLKs, tid, groundVars, c, bnd - 1));
    }
    return new Label(l=lk.l, params=params);
}

generator Type ctype(List@list<LabelKind> register, int numLKs, int tid, int groundVars, Constraint c, int bnd) {
    assert bnd > 0;
    bit t = ??;
    if (t) {
        return clabel(register, numLKs, tid, 0, c, bnd - 1);
    }
    else {
        int labelVars = makeLabelVars();  // only permit variables under functions
        Type a = type(register, numLKs, tid, groundVars, labelVars, c, bnd - 1);
        Type b = type(register, numLKs, tid, groundVars, labelVars, c, bnd - 1);
        return new Function(left=a, rite=b);
    }
    assert false;
}

adt Constraint {
    NoVars { }
    OnlyVariable { int tid; int vid; }
}
