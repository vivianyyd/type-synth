include "/home/vivianyyd/type-synth/src/main/sketch/symbolicgen/types.sk";
/*
NAME		SKETCHNAME		DUMMY
0			_0			0
tr			_tr			1
[]i			_i			2
[]b			_b			3
[[]]i			_i_0			4
cons			_cons
*/
int gVars = 0;
generator Type _0_gen() {
	return new ConcreteLabel(dummy=0);
}
generator Type _tr_gen() {
	return new ConcreteLabel(dummy=1);
}
generator Type _i_gen() {
	return new ConcreteLabel(dummy=2);
}
generator Type _b_gen() {
	return new ConcreteLabel(dummy=3);
}
generator Type _i_0_gen() {
	return new ConcreteLabel(dummy=4);
}
generator Type _cons_gen() {
	Type root;
	boolean canBeFresh = false;
	boolean canBeBoundInLabel = false;
	int lVars = 0;

	Type rootl; Type rootr;
	// input type
	canBeFresh = true;
	int flag_rootl = ??;
	assert (flag_rootl == 0 || flag_rootl == 1);
	if (flag_rootl == 0) {
		int v_rootl = ??;
		assert (v_rootl >= 0 && v_rootl < lVars + 2);
		if (!canBeFresh) assert (v_rootl != lVars);
		if (!canBeBoundInLabel) assert (v_rootl != lVars + 1);
		if (v_rootl < lVars) {
			rootl = new VarRef(id=v_rootl + gVars);
		}
		else if (v_rootl == lVars) {
			rootl = new VarBind(id=lVars + gVars);
			lVars++;
		}
		else if (v_rootl == lVars + 1) {
			rootl = new VarLabelBound();
		}
		else assert false;
	}
	if (flag_rootl == 1) {
		rootl = new Label();
		canBeBoundInLabel = true;
	}
	// output type
	canBeFresh = false;
	int flag_rootr = ??;
	assert (flag_rootr == 0 || flag_rootr == 1);
	if (flag_rootr == 0) {
		int v_rootr = ??;
		assert (v_rootr >= 0 && v_rootr < lVars + 2);
		if (!canBeFresh) assert (v_rootr != lVars);
		if (!canBeBoundInLabel) assert (v_rootr != lVars + 1);
		if (v_rootr < lVars) {
			rootr = new VarRef(id=v_rootr + gVars);
		}
		else if (v_rootr == lVars) {
			rootr = new VarBind(id=lVars + gVars);
			lVars++;
		}
		else if (v_rootr == lVars + 1) {
			rootr = new VarLabelBound();
		}
		else assert false;
	}
	if (flag_rootr == 1) {
		Type rootrl; Type rootrr;
		// input type
		canBeFresh = true;
		int flag_rootrl = ??;
		assert (flag_rootrl == 0 || flag_rootrl == 1);
		if (flag_rootrl == 0) {
			int v_rootrl = ??;
			assert (v_rootrl >= 0 && v_rootrl < lVars + 2);
			if (!canBeFresh) assert (v_rootrl != lVars);
			if (!canBeBoundInLabel) assert (v_rootrl != lVars + 1);
			if (v_rootrl < lVars) {
				rootrl = new VarRef(id=v_rootrl + gVars);
			}
			else if (v_rootrl == lVars) {
				rootrl = new VarBind(id=lVars + gVars);
				lVars++;
			}
			else if (v_rootrl == lVars + 1) {
				rootrl = new VarLabelBound();
			}
			else assert false;
		}
		if (flag_rootrl == 1) {
			rootrl = new Label();
			canBeBoundInLabel = true;
		}
		// output type
		canBeFresh = false;
		int flag_rootrr = ??;
		assert (flag_rootrr == 0 || flag_rootrr == 1);
		if (flag_rootrr == 0) {
			int v_rootrr = ??;
			assert (v_rootrr >= 0 && v_rootrr < lVars + 2);
			if (!canBeFresh) assert (v_rootrr != lVars);
			if (!canBeBoundInLabel) assert (v_rootrr != lVars + 1);
			if (v_rootrr < lVars) {
				rootrr = new VarRef(id=v_rootrr + gVars);
			}
			else if (v_rootrr == lVars) {
				rootrr = new VarBind(id=lVars + gVars);
				lVars++;
			}
			else if (v_rootrr == lVars + 1) {
				rootrr = new VarLabelBound();
			}
			else assert false;
		}
		if (flag_rootrr == 1) {
			rootrr = new Label();
			canBeBoundInLabel = true;
		}
		rootr = new Function(left=rootrl, rite=rootrr);
	}
	root = new Function(left=rootl, rite=rootr);
	gVars += lVars;
	return root;
}
harness Type _0() {
	return _0_gen();
}
harness Type _tr() {
	return _tr_gen();
}
harness Type _i() {
	return _i_gen();
}
harness Type _b() {
	return _b_gen();
}
harness Type _i_0() {
	return _i_0_gen();
}
harness Type _cons() {
	return _cons_gen();
}
harness Type oo_consco_0cc() {
	assert (isFunction(_cons()));
	Type result = apply((Function)_cons(), _0());
	assert (result != null);
	return result;
}
harness Type oooo_consco_0ccco_icc() {
	assert (isFunction(oo_consco_0cc()));
	Type result = apply((Function)oo_consco_0cc(), _i());
	assert (result != null);
	return result;
}
harness Type oooo_consco_0cccooooo_consco_0ccco_icccc() {
	assert (isFunction(oo_consco_0cc()));
	Type result = apply((Function)oo_consco_0cc(), oooo_consco_0ccco_icc());
	assert (result != null);
	return result;
}

