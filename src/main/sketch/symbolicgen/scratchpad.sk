include "/home/vivianyyd/type-synth/src/main/sketch/symbolicgen/types.sk";
/*
NAME		SKETCHNAME		DUMMY
0			_0			0
tr			_tr			1
[]i			_i			2
[]b			_b			3
[[]]i			_i_0			4
cons			_cons
*/
generator Type _0_gen() { return new ConcreteLabel(dummy=0); }
generator Type _tr_gen() { return new ConcreteLabel(dummy=1); }
generator Type _i_gen() { return new ConcreteLabel(dummy=2); }
generator Type _b_gen() { return new ConcreteLabel(dummy=3); }
generator Type _i_0_gen() { return new ConcreteLabel(dummy=4); }
generator Type _cons_gen() {
	Type root;
	boolean canBeFresh = false;
	boolean canBeBoundInLabel = false;
	int lVars = 0;

	Type rootl; Type rootr;
	// input type
	canBeFresh = true;
	int flag_rootl = ??;
	assert (flag_rootl == 0 || flag_rootl == 1);
	if (flag_rootl == 0) {
		int v_rootl = ??;
		assert (v_rootl >= 0 && v_rootl < lVars + 2);
		if (!canBeFresh) assert (v_rootl != lVars);
		if (!canBeBoundInLabel) assert (v_rootl != lVars + 1);
		if (v_rootl < lVars) { rootl = new VarRef(vId=v_rootl, tId=0); }
		else if (v_rootl == lVars) {
			rootl = new VarBind(vId=lVars, tId=0);
			lVars++;
		}
		else if (v_rootl == lVars + 1) { rootl = new VarLabelBound(); }
		else assert false;
	}
	if (flag_rootl == 1) {
		rootl = new Label();
		canBeBoundInLabel = true;
	}
	// output type
	canBeFresh = false;
	int flag_rootr = ??;
	assert (flag_rootr == 0 || flag_rootr == 1);
	if (flag_rootr == 0) {
		int v_rootr = ??;
		assert (v_rootr >= 0 && v_rootr < lVars + 2);
		if (!canBeFresh) assert (v_rootr != lVars);
		if (!canBeBoundInLabel) assert (v_rootr != lVars + 1);
		if (v_rootr < lVars) { rootr = new VarRef(vId=v_rootr, tId=0); }
		else if (v_rootr == lVars) {
			rootr = new VarBind(vId=lVars, tId=0);
			lVars++;
		}
		else if (v_rootr == lVars + 1) { rootr = new VarLabelBound(); }
		else assert false;
	}
	if (flag_rootr == 1) {
		Type rootrl; Type rootrr;
		// input type
		canBeFresh = true;
		int flag_rootrl = ??;
		assert (flag_rootrl == 0 || flag_rootrl == 1);
		if (flag_rootrl == 0) {
			int v_rootrl = ??;
			assert (v_rootrl >= 0 && v_rootrl < lVars + 2);
			if (!canBeFresh) assert (v_rootrl != lVars);
			if (!canBeBoundInLabel) assert (v_rootrl != lVars + 1);
			if (v_rootrl < lVars) { rootrl = new VarRef(vId=v_rootrl, tId=0); }
			else if (v_rootrl == lVars) {
				rootrl = new VarBind(vId=lVars, tId=0);
				lVars++;
			}
			else if (v_rootrl == lVars + 1) { rootrl = new VarLabelBound(); }
			else assert false;
		}
		if (flag_rootrl == 1) {
			rootrl = new Label();
			canBeBoundInLabel = true;
		}
		// output type
		canBeFresh = false;
		int flag_rootrr = ??;
		assert (flag_rootrr == 0 || flag_rootrr == 1);
		if (flag_rootrr == 0) {
			int v_rootrr = ??;
			assert (v_rootrr >= 0 && v_rootrr < lVars + 2);
			if (!canBeFresh) assert (v_rootrr != lVars);
			if (!canBeBoundInLabel) assert (v_rootrr != lVars + 1);
			if (v_rootrr < lVars) { rootrr = new VarRef(vId=v_rootrr, tId=0); }
			else if (v_rootrr == lVars) {
				rootrr = new VarBind(vId=lVars, tId=0);
				lVars++;
			}
			else if (v_rootrr == lVars + 1) { rootrr = new VarLabelBound(); }
			else assert false;
		}
		if (flag_rootrr == 1) {
			rootrr = new Label();
			canBeBoundInLabel = true;
		}
		rootr = new Function(left=rootrl, rite=rootrr);
	}
	root = new Function(left=rootl, rite=rootr);
	return root;
}
harness Type _0() { return _0_gen(); }
harness Type _tr() { return _tr_gen(); }
harness Type _i() { return _i_gen(); }
harness Type _b() { return _b_gen(); }
harness Type _i_0() { return _i_0_gen(); }
harness Type _cons() { return _cons_gen(); }
harness Type oo_consco_0cc() {
	assert (isFunction(_cons()));
	Type result = apply((Function)_cons(), _0());
	assert (result != null);
	return result;
}
harness Type oooo_consco_0ccco_icc() {
	assert (isFunction(oo_consco_0cc()));
	Type result = apply((Function)oo_consco_0cc(), _i());
	assert (result != null);
	return result;
}
harness Type oooo_consco_0cccooooo_consco_0ccco_icccc() {
	assert (isFunction(oo_consco_0cc()));
	Type result = apply((Function)oo_consco_0cc(), oooo_consco_0ccco_icc());
	assert (result != null);
	return result;
}
harness Type oo_consco_trcc() {
	assert (isFunction(_cons()));
	Type result = apply((Function)_cons(), _tr());
	assert (result != null);
	return result;
}
harness Type oooo_consco_trccco_bcc() {
	assert (isFunction(oo_consco_trcc()));
	Type result = apply((Function)oo_consco_trcc(), _b());
	assert (result != null);
	return result;
}
harness Type oooo_consco_trcccooooo_consco_trccco_bcccc() {
	assert (isFunction(oo_consco_trcc()));
	Type result = apply((Function)oo_consco_trcc(), oooo_consco_trccco_bcc());
	assert (result != null);
	return result;
}
harness Type oo_consco_icc() {
	assert (isFunction(_cons()));
	Type result = apply((Function)_cons(), _i());
	assert (result != null);
	return result;
}
harness Type oooo_consco_iccco_i_0cc() {
	assert (isFunction(oo_consco_icc()));
	Type result = apply((Function)oo_consco_icc(), _i_0());
	assert (result != null);
	return result;
}
harness Type oooo_consco_icccooooo_consco_iccco_i_0cccc() {
	assert (isFunction(oo_consco_icc()));
	Type result = apply((Function)oo_consco_icc(), oooo_consco_iccco_i_0cc());
	assert (result != null);
	return result;
}

harness void neq() { assert (_cons() != new Function(left=new VarBind(vId=0, tId=0), rite=new Function(left=new Label(), rite=new Label()))); }
