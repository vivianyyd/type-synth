include "/home/vivianyyd/type-synth/src/main/sketch/symbolicgen/types.sk";
include "/home/vivianyyd/applications/sketch-1.7.6/sketch-frontend/sketchlib/list.skh";

generator Type _cons_gen() {
	Type root;
	boolean canBeFresh = false;
	boolean canBeBoundInLabel = false;
	int numVarsNextId = 0;
	//TODO canBeFresh need not be in Sketch, it is a property of the tree shape not choices

	Type rootl; Type rootr;
	// input type
	canBeFresh = true;
	int flag_rootl = ??;
	assert (flag_rootl == 0 || flag_rootl == 1);
	if (flag_rootl == 0) {
	    int v = ??;
	    assert (v >= 0 && v < numVarsNextId + 2);
	    if (!canBeFresh) assert (v != numVarsNextId)
	    if (!canBeBoundInLabel) assert (v != numVarsNextId + 1);
        if (v < numVarsNextId) {
	        rootl = new VarRef(id=get(vars, i));
	    }
	    else if (v == numVarsNextId) {
	        rootl = new VarBind(id=numVarsNextId);
            numVarsNextId++;
	    }
        else if (v == numVarsNextId + 1) {
            rootl = new VarLabelBound();
        }
		else assert false;
	}
	if (flag_rootl == 1) {
		rootl = new Label();
		canBeBoundInLabel = true;
	}
	// output type
	canBeFresh = false;
	int flag_rootr = ??;
	assert (flag_rootr == 0 || flag_rootr == 1);
	if (flag_rootr == 0) {
		List<int> bindings;
		if (!(canBeFresh || canBeBoundInLabel)) bindings = vars;
		rootr = new Var(id=numVarsNextId, possBindings=bindings);
		numVarsNextId++;
	}
	if (flag_rootr == 1) {
		Type rootrl; Type rootrr;
		// input type
		canBeFresh = true;
		int flag_rootrl = ??;
		assert (flag_rootrl == 0 || flag_rootrl == 1);
		if (flag_rootrl == 0) {
			List<int> bindings;
			if (!(canBeFresh || canBeBoundInLabel)) bindings = vars;
			rootrl = new Var(id=numVarsNextId, possBindings=bindings);
			numVarsNextId++;
		}
		if (flag_rootrl == 1) {
			rootrl = new Label();
			canBeBoundInLabel = true;
		}
		// output type
		canBeFresh = false;
		int flag_rootrr = ??;
		assert (flag_rootrr == 0 || flag_rootrr == 1);
		if (flag_rootrr == 0) {
			List<int> bindings;
			if (!(canBeFresh || canBeBoundInLabel)) bindings = vars;
			rootrr = new Var(id=numVarsNextId, possBindings=bindings);
			numVarsNextId++;
		}
		if (flag_rootrr == 1) {
			rootrr = new Label();
			canBeBoundInLabel = true;
		}
		rootr = new Function(left=rootrl, rite=rootrr);
	}
	root = new Function(left=rootl, rite=rootr);
	return root;
}
harness Type _0() {
	return _0_gen();
}
harness Type _tr() {
	return _tr_gen();
}
harness Type _i() {
	return _i_gen();
}
harness Type _b() {
	return _b_gen();
}
harness Type _i_0() {
	return _i_0_gen();
}
harness Type oo_consco_0cc() {
	assert (isFunction(_cons()));
	assert (apply(_0(), ((Function)_cons()).left));
	return ((Function)_cons()).rite;
}
harness Type oooo_consco_0ccco_icc() {
	assert (isFunction(oo_consco_0cc()));
	assert (apply(_i(), ((Function)oo_consco_0cc()).left));
	return ((Function)oo_consco_0cc()).rite;
}
harness Type oooo_consco_0cccooooo_consco_0ccco_icccc() {
	assert (isFunction(oo_consco_0cc()));
	assert (apply(oooo_consco_0ccco_icc(), ((Function)oo_consco_0cc()).left));
	return ((Function)oo_consco_0cc()).rite;
}
harness Type _cons() {
	return _cons_gen();
}

