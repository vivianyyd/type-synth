include "/home/vivianyyd/type-synth/src/main/sketch/symbolicgen/types.sk";
include "/home/vivianyyd/applications/sketch-1.7.6/sketch-frontend/sketchlib/list.skh";

generator Type _cons_gen() {
	Type root;
	boolean canBeFresh = false;
	boolean canBeBoundInLabel = false;
	int varId = 0;
	List<int> vars = empty();
	//TODO canBeFresh doesn't need to be in Sketch, this is a property of the tree shape not choices

	Type rootl; Type rootr;
	// input type
	canBeFresh = true;
	int flag_rootl = ??;
	assert (flag_rootl == 0 || flag_rootl == 1);
	if (flag_rootl == 0) {
		List<int> bindings;
		if (!(canBeFresh || canBeBoundInLabel)) bindings = vars;
		rootl = new Var(id=varId, possBindings=bindings);
		vars = add(vars, varId);
		varId++;
	}
	if (flag_rootl == 1) {
		rootl = new Label();
		canBeBoundInLabel = true;
	}
	// output type
	canBeFresh = false;
	int flag_rootr = ??;
	assert (flag_rootr == 0 || flag_rootr == 1);
	if (flag_rootr == 0) {
		List<int> bindings;
		if (!(canBeFresh || canBeBoundInLabel)) bindings = vars;
		rootr = new Var(id=varId, possBindings=bindings);
		vars = add(vars, varId);
		varId++;
	}
	if (flag_rootr == 1) {
		Type rootrl; Type rootrr;
		// input type
		canBeFresh = true;
		int flag_rootrl = ??;
		assert (flag_rootrl == 0 || flag_rootrl == 1);
		if (flag_rootrl == 0) {
			List<int> bindings;
			if (!(canBeFresh || canBeBoundInLabel)) bindings = vars;
			rootrl = new Var(id=varId, possBindings=bindings);
			vars = add(vars, varId);
			varId++;
		}
		if (flag_rootrl == 1) {
			rootrl = new Label();
			canBeBoundInLabel = true;
		}
		// output type
		canBeFresh = false;
		int flag_rootrr = ??;
		assert (flag_rootrr == 0 || flag_rootrr == 1);
		if (flag_rootrr == 0) {
			List<int> bindings;
			if (!(canBeFresh || canBeBoundInLabel)) bindings = vars;
			rootrr = new Var(id=varId, possBindings=bindings);
			vars = add(vars, varId);
			varId++;
		}
		if (flag_rootrr == 1) {
			rootrr = new Label();
			canBeBoundInLabel = true;
		}
		rootr = new Function(left=rootrl, rite=rootrr);
	}
	root = new Function(left=rootl, rite=rootr);
	return root;
}
harness Type _0() {
	return _0_gen();
}
harness Type _tr() {
	return _tr_gen();
}
harness Type _i() {
	return _i_gen();
}
harness Type _b() {
	return _b_gen();
}
harness Type _i_0() {
	return _i_0_gen();
}
harness Type oo_consco_0cc() {
	assert (isFunction(_cons()));
	assert (leq(_0(), ((Function)_cons()).left));
	return ((Function)_cons()).rite;
}
harness Type oooo_consco_0ccco_icc() {
	assert (isFunction(oo_consco_0cc()));
	assert (leq(_i(), ((Function)oo_consco_0cc()).left));
	return ((Function)oo_consco_0cc()).rite;
}
harness Type oooo_consco_0cccooooo_consco_0ccco_icccc() {
	assert (isFunction(oo_consco_0cc()));
	assert (leq(oooo_consco_0ccco_icc(), ((Function)oo_consco_0cc()).left));
	return ((Function)oo_consco_0cc()).rite;
}
harness Type _cons() {
	return _cons_gen();
}

