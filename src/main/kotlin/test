// cons
// secretly:
// t1 = int
// t2 = [int]
// t3 = [[int]]


cons p1 p2 = p3

// ``type application'', can be discovered by just checking equality or whatever
cons t1 t2 = t2  // can be read as p1 = t1, p2 = t2 implies p3 = t2
cons t2 t3 = t3
cons int t2 = t2

need to distinguish this from the fn that takes any p1 and produces the identity fn


Equality(
    TypeApplication("cons", listOf(Parameter("cons", 0), Parameter("cons", 1))),
    Parameter("cons", 2)
),
Equality(
    TypeApplication("cons", listOf(UnknownType("t1"), UnknownType("t2"))),
    UnknownType("t2")
),
Equality(
    TypeApplication("cons", listOf(UnknownType("t2"), UnknownType("t3"))),
    UnknownType("t3")
),
Equality(
    TypeApplication("cons", listOf(LiteralTree(LiteralLabel("int"), listOf()), UnknownType("t2"))),
    UnknownType("t2")
),












/*
struct Point{
    int x;
    int y;
}
void main(){
    Point p2 = new Point(x=5, y=7);
    assert p2.x == 5 && p2.y == 7; //Fields initialized by constructor.
}

The expression for the array size can involve any final expression in scope. includes holes?

TODO try encoding the whole thing as a sketch problem
or by introducing constraints one by one
I don't think we can use sketch's equals
*/

include "array.skh";

adt Nullable<T> {
    None
    Some { T elem; }
}

adt Label {
    LiteralLabel { SArray<char> label; }
    NodeLabel { Tree node; }
}
adt Tree{
    LiteralTree { Label label; Array<Tree> children }
    Unknown { SArray<char> name; Nullable<Label> label; Nullable<Array<Tree>> children }
    Parameter { int index; }
    Child { Tree parent, int index }
    TypeApplication { SArray<char> fn; Array<Tree> args }
}

// TODO maybe we want normal arrays so we can make the size a hole. But can you have holes inside an ADT? I don't think so
//   we wanna see if SAT a node is a node with no children
//   is there an example such that its a LiteralTree with children==None or Unknown with children==None
=========================================================================================================================================================

// -------------------- Grammar of properties ------------------------
generator boolean U_gen(int x0, int x1, int x2, int o, int n) {
	if (n > 0) {
		int e1 = U_gen_expr(x0, x1, x2, o, n - 1);
		int e2 = U_gen_expr(x0, x1, x2, o, n - 1);
		return U_gen_cmp(e1, e2, n - 1);
	}
	assert false;
}
generator boolean U_gen_cmp(int x, int y, int n) {
	if (n > 0) {
		int t = ??;
		if (t == 0) { return x == y; }
		if (t == 1) { return x <= y; }
		if (t == 2) { return x >= y; }
		if (t == 3) { return x < y; }
		if (t == 4) { return x > y; }
		return x != y;
	}
	assert false;
}
generator int U_gen_expr(int x0, int x1, int x2, int o, int n) {
	if (n > 0) {
		int t = ??;
		if (t == 0) { return 0; }
		if (t == 1) { return 1; }
		if (t == 2) { return length(x0); }
		if (t == 3) { return length(o); }
		int e1 = U_gen_expr(x0, x1, x2, o, n - 1);
		int e2 = U_gen_expr(x0, x1, x2, o, n - 1);
		return U_gen_op(e1, e2, n - 1);
	}
	assert false;
}
generator int U_gen_op(int x, int y, int n) {
	if (n > 0) {
		int t = ??;
		if (t == 0) { return x + y; }
		if (t == 1) { return x * y; }
		return x - y;
	}
	assert false;
}
// -------------------- End grammar of properties ------------------------

generator void negative_example_gen(ref int x0, ref int x1, ref int x2, ref int o){
	int t = ??;
	x0 = get_ex(t, 0);
	x1 = get_ex(t, 1);
	x2 = get_ex(t, 2);
	o = dummy_out();
	int real_out = get_ex(t, 3);
	assert o != real_out;
}
void negative_example(ref int x0, ref int x1, ref int x2, ref int o){
	negative_example_gen(x0, x1, x2, o);
}
// Returns the ith argument of the tth example.
	int get_ex(int t, int i) {
	if (t == 0 && i == 0) { return 0; }
	if (t == 0 && i == 1) { return 1; }
	if (t == 0 && i == 2) { return 2; }
	if (t == 0 && i == 3) { return 3; }
	if (t == 1 && i == 0) { return 4; }
	if (t == 1 && i == 1) { return 5; }
	if (t == 1 && i == 2) { return 6; }
	if (t == 1 && i == 3) { return 7; }
	if (t == 2 && i == 0) { return 8; }
	if (t == 2 && i == 1) { return 6; }
	if (t == 2 && i == 2) { return 9; }
	if (t == 2 && i == 3) { return 10; }
	assert false;
}
generator int dummy_out() {
	int t = ??;
	if (t == 0) { return 3; }
	if (t == 1) { return 7; }
	if (t == 2) { return 10; }
	assert false;
}

// -------------------- Begin examples ------------------------
harness void positive_example_0 () {
	boolean out;
	int x0 = 0;
	int x1 = 1;
	int x2 = 2;
	int o = 3;
	property(x0, x1, x2, o, out);
	assert out;
}
harness void positive_example_1 () {
	boolean out;
	int x0 = 4;
	int x1 = 5;
	int x2 = 6;
	int o = 7;
	property(x0, x1, x2, o, out);
	assert out;
}
harness void positive_example_2 () {
	boolean out;
	int x0 = 8;
	int x1 = 6;
	int x2 = 9;
	int o = 10;
	property(x0, x1, x2, o, out);
	assert out;
}

harness void negative_example_0 () {
	boolean out;
	int x0 = 8;
	int x1 = 6;
	int x2 = 9;
	int o = 7;
	property(x0, x1, x2, o, out);
	assert !out;
}


harness void negative_example_1 () {
	boolean out;
	int x0 = 4;
	int x1 = 5;
	int x2 = 6;
	int o = 3;
	property(x0, x1, x2, o, out);
	assert !out;
}

// -------------------- End examples ------------------------

generator boolean property_gen(int x0, int x1, int x2, int o) {
	if (??) { return false; }
	int n = ??;
	boolean atom_0 = U_gen(x0, x1, x2, o, n);
	minimize(n);
	return atom_0;
}
void property(int x0, int x1, int x2, int o, ref boolean out) {
	out = property_gen(x0, x1, x2, o);
}
void obtained_property(int x0, int x1, int x2, int o, ref boolean out) {
	out = length(x0) == length(o);
}

void property_conj(int x0, int x1, int x2, int o, ref boolean out) {
	out = true;
}
harness void precision() {
	int x0 = 0;
	int x1 = 0;
	int x2 = 0;
	int o = 0;
	negative_example(x0, x1, x2, o);
	boolean out_1;
	obtained_property(x0, x1, x2, o, out_1);
	assert out_1;

	boolean out_2;
	property_conj(x0, x1, x2, o, out_2);
	assert out_2;

	boolean out_3;
	property(x0, x1, x2, o, out_3);
	assert !out_3;
}

