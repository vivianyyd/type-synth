// cons
// secretly:
// t1 = int
// t2 = [int]
// t3 = [[int]]


cons p1 p2 = p3

// ``type application'', can be discovered by just checking equality or whatever
cons t1 t2 = t2  // can be read as p1 = t1, p2 = t2 implies p3 = t2
cons t2 t3 = t3
cons int t2 = t2

need to distinguish this from the fn that takes any p1 and produces the identity fn


Equality(
    TypeApplication("cons", listOf(Parameter("cons", 0), Parameter("cons", 1))),
    Parameter("cons", 2)
),
Equality(
    TypeApplication("cons", listOf(UnknownType("t1"), UnknownType("t2"))),
    UnknownType("t2")
),
Equality(
    TypeApplication("cons", listOf(UnknownType("t2"), UnknownType("t3"))),
    UnknownType("t3")
),
Equality(
    TypeApplication("cons", listOf(LiteralTree(LiteralLabel("int"), listOf()), UnknownType("t2"))),
    UnknownType("t2")
),




// TODO this is kinda dumb bc we can just linear scan for this in Kotlin
// TODO try concrete fixed type and total type equality first
//    (concrete can be subsumed by total type eq?)









/*
TODO try encoding the whole thing as a sketch problem
or by introducing constraints one by one
I don't think we can use sketch's equals
*/

// TODO maybe we want normal arrays so we can make the size a hole. But can you have holes inside an ADT? I don't think so
//   we wanna see if SAT a node is a node with no children
//   is there an example such that its a LiteralTree with children==None or Unknown with children==None
=========================================================================================================================================================
