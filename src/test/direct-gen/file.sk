package UTIL;

include "/home/vivianyyd/applications/sketch-1.7.6/sketch-frontend/sketchlib/array.skh";

int MAX_NUM_VARS = 3;

adt Type{
    Variable { int id; }
    Function { Type in; Type out; }
    Node { int label; Array<Type> params; }
    Error { }
}

// TODO see if this actually helps
generator int bounded_number(int bound) {
    int n = ??;
    assert n > -1 && n < bound;
    return n;
}

generator Type type() {
    int t = ??;
    if (t == 1) { return new Variable(id = bounded_number(2*MAX_NUM_VARS)); }  // arbitrarily picked
    Type a = type();
    Type b = type();
    if (t == 2) { return new Function(in = a, out = b); }
    if (t == 3) {
        int n_params = ??;
        assert n_params < MAX_NUM_VARS;
        Array<Type> arr = newArray();
        for (int i = 0; i < n_params; i++) {
            Type elem;
            // Reuse previous calls to type generator
            if (i == 0) { elem = a; }
            if (i == 1) { elem = b; }
            else { elem = type(); }
            add(arr, elem);
        }
        return new Node(label = bounded_number(2*MAX_NUM_VARS), params=arr);
    }
}

struct UnificationResult {
    Type type;
    Type[MAX_NUM_VARS] var_map;
}

UnificationResult unifyVar(Variable var, Type target, Type[MAX_NUM_VARS] var_map) {
    if (var_map[var.id] != null) { return unify(var_map[var.id], target, var_map); }
    else {  // todo test this actually checks variable not in map
        var_map[var.id] = target;
        return new UnificationResult(type=target, var_map=var_map);
    }
}

UnificationResult unify(Type a, Type b, Type[MAX_NUM_VARS] var_map) {
    // TODO remove the assert falses from unifying Errors
    switch(a){
        case Variable:{
            // There needs to be a switch on b directly under each case, since we want errors to redirect quickly.
            switch(b){
                case Variable:{
                    // Unwrap b if possible
                    if (var_map[b.id] != null) { return unify(var_map[b.id], a, var_map); }
                    return unifyVar(a, b, var_map);
                }
                case Function:{ return unifyVar(a, b, var_map); }
                case Node:{ return unifyVar(a, b, var_map); }
                case Error:{ assert false; return new UnificationResult(type=b, var_map=var_map); }
            }
        }
        case Function:{
            switch(b){
                case Variable:{ return unifyVar(b, a, var_map); }
                case Function:{
                    UnificationResult curry = unify(a.in, b.in, var_map);  // TODO is this even a sensible name
                    return unify(a.out, b.out, curry.var_map);
                }
                case Node:{ assert false; }
                case Error:{ assert false; return new UnificationResult(type=b, var_map=var_map); }
            }
        }
        case Node:{
            switch(b){
                case Variable:{ return unifyVar(b, a, var_map); }
                case Function:{ assert false; }
                case Node:{
                    assert a.label == b.label;
                    assert a.params.sz == b.params.sz;
                    for (int i = 0; i < a.params.sz; i++) {
                        // params should be independent, so the var map shouldn't change between them
                        unify(a.params.inner.val[i], b.params.inner.val[i], var_map);
                    }
                    return new UnificationResult(type=a, var_map=var_map);
                }
                case Error:{ assert false; return new UnificationResult(type=b, var_map=var_map); }
            }
        }
        case Error:{ assert false; return new UnificationResult(type=a, var_map=var_map); }
    }
}

// TODO make this work
//T arrayOf<T>(int n, T[n] elems) {
//    Array<T> arr = newArray();
//    for (int i = 0; i < n; i++) {
//        add(arr, elems[i]);
//    }
//    return arr;
//}

Type generated_function_type() {
    return type();
}

// For each test which is an example of application,
harness void passes_positives(int t) {
    assume t > -1 && t < 3;
    Type fun_type = generated_function_type();  // todo this will be produced by calling generator

    // a -> a list
//    Type alpha = new Variable(id=2);
//    Array<Type> childAlpha = newArray();
//    add(childAlpha, alpha);
//    Type listAlpha = new Node(label=1, params=childAlpha);
//    Type fun_type = new Function(in=alpha, out=listAlpha);

    // int -> int list
    Type intNode = new Node(label=0, params=newArray());
    Array<Type> childInt = newArray();
    add(childInt, intNode);
    Type listIntNode = new Node(label=1, params=childInt);
    Type example = new Function(in=intNode, out=listIntNode);

    Type[MAX_NUM_VARS] map;
    UnificationResult dummy = unify(fun_type, example, map);

    // int -> int
//    Type negative_example = new Function(in=intNode, out=intNode);
//    Type[MAX_NUM_VARS] map2;
//    UnificationResult dummy2 = unify(fun_type, negative_example, map2);

    // bool -> int list
//    Type boolNode = new Node(label=3, params=newArray());
//    Type negative_example2 = new Function(in=boolNode, out=listIntNode);
//    Type[MAX_NUM_VARS] map3;
//    UnificationResult dummy3 = unify(fun_type, negative_example2, map3);

    // TODO Think about how to unify errors actually
    // TODO will it work if I just force all negative examples to unify with Error or something, maybe this is why we need an Apply function

// TODO Function type was not inlined enough. Increase inlining with --inlineamnt flag.

/*
adt Type{
    Variable { int id; }
    Function { Type in; Type out; }
    Node { int label; Array<Type> params; }
    Error { }
}
*/
    // TODO The example might only be a partial application, account for that eventually.
    //      Or maybe we only apply one argument by default? Idk. Why can't we just unify the whole function with each
    //      example rather than calling "Apply" like on the whiteboard
}
