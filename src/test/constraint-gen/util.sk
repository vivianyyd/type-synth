package UTIL;

// TODO names can just be integer identifiers
// -------------------------------- Definitions ----------------------------------
adt Label {
    LiteralLabel { SArray<char> label; }
    NodeLabel { Tree node; }
}

adt Tree{
    LiteralTree { Label label; Array<Tree> children; }  // fully concrete
    Unknown { SArray<char> name; Label label; Array<Tree> children; }  // l of alpha, but with uncertainty
    Parameter { int index; }  // alpha
    Child { Tree parent; int index; }  // child of somebody else
    TypeApplication { SArray<char> fn; Array<Tree> args; }
    Dummy { }  // TODO idk
}

// -------------------------------- Helpful constructors ----------------------------------
SArray<char> str(int len, char[len] s) {
    return new SArray<char>(n=len, val=s);
}

Array<Tree> zeroChildren() {
    return newArray();
}

Unknown newUnknown(int len, char[len] name) {
    return new Unknown(name = str(len, name), label=null, children=null);
}

// -------------------------------- Equals ----------------------------------

// Does comparison only one level down, not deep equals
boolean equalsSArray<T>(SArray<T> a, SArray<T> b) {
    return (a == null && b == null) || (a.val == b.val);
}

boolean equalsArray<T>(Array<T> a, Array<T> b) {
    return (a == null && b == null) || equalsSArray(a.inner, b.inner);
}

boolean equalsLabel(Label a, Label b) {
    if (a == null && b == null) return true;
    switch(a){
        case LiteralLabel:{
            switch(b){
                case LiteralLabel:{ return equalsSArray(a.label, b.label); }
                case NodeLabel:{ return false; }
            }
        }
        case NodeLabel:{
            switch(b){
                case LiteralLabel:{ return false; }
                case NodeLabel:{ return equalsTree(a.node, b.node); }
                // TODO I think this is a broken cyclic call and should be fixed once I figure out how to represent stuff
            }
        }
    }
}

// Because comparing refs uses physical equality, and we pass around refs a lot for multiple returns
boolean equalsTree(Tree a, Tree b) {
    if (a == null && b == null) return true;
    switch(a){
        case LiteralTree:{
            switch(b){
                case LiteralTree:{
                    return a.label == b.label && equalsArray(a.children, b.children);
                }
                case Unknown:{ return false; }
                case Parameter:{ return false; }
                case Child:{ return false; }
                case TypeApplication:{ return false; }
                case Dummy:{ return false; }
            }
        }
        case Unknown:{
            switch(b){
                case LiteralTree:{ return false; }
                case Unknown:{
                    return equalsSArray(a.name, b.name) && equalsLabel(a.label, b.label) && equalsArray(a.children, b.children);
                }
                case Parameter:{ return false; }
                case Child:{ return false; }
                case TypeApplication:{ return false; }
                case Dummy:{ return false; }
            }
        }
        case Parameter:{
            switch(b){
                case LiteralTree:{ return false; }
                case Unknown:{ return false; }
                case Parameter:{ return a.index == b.index; }
                case Child:{ return false; }
                case TypeApplication:{ return false; }
                case Dummy:{ return false; }
            }
        }
        case Child:{
            switch(b){
                case LiteralTree:{ return false; }
                case Unknown:{ return false; }
                case Parameter:{ return false; }
                case Child:{ return a.parent == b.parent && a.index == b.index; }
                case TypeApplication:{ return false; }
                case Dummy:{ return false; }
            }
        }
        case TypeApplication:{
            switch(b){
                case LiteralTree:{ return false; }
                case Unknown:{ return false; }
                case Parameter:{ return false; }
                case Child:{ return false; }
                case TypeApplication:{ return equalsSArray(a.fn, b.fn) && equalsArray(a.args, b.args); }
                case Dummy:{ return false; }
            }
        }
        case Dummy:{
            switch(b){
                case LiteralTree:{ return false; }
                case Unknown:{ return false; }
                case Parameter:{ return false; }
                case Child:{ return false; }
                case TypeApplication:{ return false; }
                case Dummy:{ return true; }
            }
        }
    }
    assert false;
}
