include "/home/vivianyyd/applications/sketch-1.7.6/sketch-frontend/sketchlib/array.skh";

// -------------------------------- Definitions ----------------------------------
adt Nullable<T> {
    None { }
    Some { T elem; }
}

adt Label {
    LiteralLabel { SArray<char> label; }
    NodeLabel { Tree node; }
}

adt Tree{
    LiteralTree { Label label; Nullable<Array<Tree>> children; }
    Unknown { SArray<char> name; Nullable<Label> label; Nullable<Array<Tree>> children; }
    Parameter { int index; }
    Child { Tree parent; int index; }
    TypeApplication { SArray<char> fn; Array<Tree> args; }
    Dummy { }  // TODO idk
}


// -------------------------------- Helpers ----------------------------------
SArray<char> str(int len, char[len] s) {
    return new SArray<char>(n=len, val=s);
}

Nullable<Label> noLabel() {
    return new None<Label>();
}

Nullable<Array<Tree>> noChildren() {
    return new None<Array<Tree>>();
}

Nullable<Array<Tree>> zeroChildren() {
    return new Some<Array<Tree>>(newArray<Tree>());
}

Tree newUnknown(int len, char[len] name) {
    return new Unknown(name = str(len, name), label=noLabel(), children=noChildren());
}

// -------------------------------- Constraint trying ----------------------------------
generator void positive_example_finder(ref Tree x0, ref Tree x1, ref Tree o){
    int t = ??;
    if (t == 0) {
        x0 = new LiteralTree(
                    label = new LiteralLabel(label = str(4, "int")),
                    children = zeroChildren()
                );
        x1 = newUnknown(3, "t2");
        o = newUnknown(3, "t2");
    }
    else if (t == 1) {
        x0 = newUnknown(3, "t1");
        x1 = newUnknown(3, "t2");
        o = newUnknown(3, "t2");
    }
    else if (t == 2) {
        x0 = newUnknown(3, "t2");
        x1 = newUnknown(3, "t3");
        o = newUnknown(3, "t3");
    }
    else {
        assert false;
    }
}

void positive_example(ref Tree x0, ref Tree x1, ref Tree o){
	positive_example_finder(x0, x1, o);
}

// TODO this is kinda dumb bc we can just linear scan for this in Kotlin
// TODO try concrete fixed type and total type equality first
//    (concrete can be subsumed by total type eq?)
harness void not_parametrized() {
	Tree x0 = new Dummy();
	Tree x1 = new Dummy();
	Tree o = new Dummy();
	positive_example(x0, x1, o);

    switch(x0){  // we'll make separate copies of this function for each argument
        case LiteralTree:{
             assert x0.children == zeroChildren();
        }
        case Unknown:{
             assert x0.children == zeroChildren();
        }
        case Parameter:{
            assert false;
        }
        case Child:{
            assert false;
        }
        case TypeApplication:{
            assert false;
        }
        case Dummy:{
            assert false;
        }
    }
}
