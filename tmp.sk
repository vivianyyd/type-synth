include "/home/vivianyyd/applications/sketch-1.7.6/sketch-frontend/sketchlib/array.skh";

// Returns the ith argument of the tth example.
Tree get_ex(int t, int i) {
	if (t == 0) {
	    if (i == 0) {
	        return new LiteralTree(label = new LiteralLabel(label = str(4, "int")),
                                   children = zeroChildren());
	    }
	    if (i == 1) { return newUnknown(3, "t2"); }
	    if (i == 2) { return newUnknown(3, "t2"); }
	}
    if (t == 1) {
        if (i == 0) { return newUnknown(3, "t1"); }
        if (i == 1) { return newUnknown(3, "t2"); }
        if (i == 2) { return newUnknown(3, "t2"); }
    }
    if (t == 2) {
        if (i == 0) { return newUnknown(3, "t2"); }
        if (i == 1) { return newUnknown(3, "t3"); }
        if (i == 2) { return newUnknown(3, "t3"); }
    }
}

void positive_example_finder(ref Tree x0, ref Tree x1, ref Tree o){
    int t = ??;
    x0 = get_ex(t, 0);
    x1 = get_ex(t, 1);
    o = get_ex(t, 2);
}

void negative_example_finder(ref Tree x0, ref Tree x1, ref Tree o){
    int t = ??;
    x0 = get_ex(t, 0);
    x1 = get_ex(t, 1);
    Tree real_o = get_ex(t, 2);

    int s = ??;
    o = get_ex(s, 2);
    assert o != real_o;
}

void positive_example(ref Tree x0, ref Tree x1, ref Tree o){
	positive_example_finder(x0, x1, o);
}

void negative_example(ref Tree x0, ref Tree x1, ref Tree o){
	negative_example_finder(x0, x1, o);
}

// For all selections of examples, x1 and o match
harness void type_equality(int t) {
    assume t <= 3;  // the number of examples goes here
	Tree x0 = get_ex(t, 0);
	Tree x1 = get_ex(t, 1);
	Tree o =  get_ex(t, 2);
    assert equalsTree(x1, o);
}

// ================================ Beginning of boilerplate ======================================
// -------------------------------- Definitions ----------------------------------
adt Label {
    LiteralLabel { SArray<char> label; }
    NodeLabel { Tree node; }
}

adt Tree{
    LiteralTree { Label label; Array<Tree> children; }
    Unknown { SArray<char> name; Label label; Array<Tree> children; }
    Parameter { int index; }
    Child { Tree parent; int index; }
    TypeApplication { SArray<char> fn; Array<Tree> args; }
    Dummy { }  // TODO idk
}

// -------------------------------- Helpful constructors ----------------------------------
SArray<char> str(int len, char[len] s) {
    return new SArray<char>(n=len, val=s);
}

Array<Tree> zeroChildren() {
    return newArray();
}

Unknown newUnknown(int len, char[len] name) {
    return new Unknown(name = str(len, name), label=null, children=null);
}

// -------------------------------- Equals ----------------------------------

// Does comparison only one level down, not deep equals
boolean equalsSArray<T>(SArray<T> a, SArray<T> b) {
    return (a == null && b == null) || (a.val == b.val);
}

boolean equalsArray<T>(Array<T> a, Array<T> b) {
    return (a == null && b == null) || equalsSArray(a.inner, b.inner);
}

boolean equalsLabel(Label a, Label b) {
    if (a == null && b == null) return true;
    switch(a){
        case LiteralLabel:{
            switch(b){
                case LiteralLabel:{ return equalsSArray(a.label, b.label); }
                case NodeLabel:{ return false; }
            }
        }
        case NodeLabel:{
            switch(b){
                case LiteralLabel:{ return false; }
                case NodeLabel:{ return equalsTree(a.node, b.node); }
                // TODO I think this is a broken cyclic call and should be fixed once I figure out how to represent stuff
            }
        }
    }
}

// Because comparing refs uses physical equality, and we pass around refs a lot for multiple returns
boolean equalsTree(Tree a, Tree b) {
    if (a == null && b == null) return true;
    switch(a){
        case LiteralTree:{
            switch(b){
                case LiteralTree:{
                    return a.label == b.label && equalsArray(a.children, b.children);
                }
                case Unknown:{ return false; }
                case Parameter:{ return false; }
                case Child:{ return false; }
                case TypeApplication:{ return false; }
                case Dummy:{ return false; }
            }
        }
        case Unknown:{
            switch(b){
                case LiteralTree:{ return false; }
                case Unknown:{
                    return equalsSArray(a.name, b.name) && equalsLabel(a.label, b.label) && equalsArray(a.children, b.children);
                }
                case Parameter:{ return false; }
                case Child:{ return false; }
                case TypeApplication:{ return false; }
                case Dummy:{ return false; }
            }
        }
        case Parameter:{
            switch(b){
                case LiteralTree:{ return false; }
                case Unknown:{ return false; }
                case Parameter:{ return a.index == b.index; }
                case Child:{ return false; }
                case TypeApplication:{ return false; }
                case Dummy:{ return false; }
            }
        }
        case Child:{
            switch(b){
                case LiteralTree:{ return false; }
                case Unknown:{ return false; }
                case Parameter:{ return false; }
                case Child:{ return a.parent == b.parent && a.index == b.index; }
                case TypeApplication:{ return false; }
                case Dummy:{ return false; }
            }
        }
        case TypeApplication:{
            switch(b){
                case LiteralTree:{ return false; }
                case Unknown:{ return false; }
                case Parameter:{ return false; }
                case Child:{ return false; }
                case TypeApplication:{ return equalsSArray(a.fn, b.fn) && equalsArray(a.args, b.args); }
                case Dummy:{ return false; }
            }
        }
        case Dummy:{
            switch(b){
                case LiteralTree:{ return false; }
                case Unknown:{ return false; }
                case Parameter:{ return false; }
                case Child:{ return false; }
                case TypeApplication:{ return false; }
                case Dummy:{ return true; }
            }
        }
    }
    assert false;
}

